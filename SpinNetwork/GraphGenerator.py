import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
from sklearn.decomposition import PCA
import random

from visual import (plot_all_matrices_with_pca, visualize_graph, 
                    plot_star_and_random_with_pca, visualize_bloch_vectors, 
                    visualize_parameters, plot_random_with_pca_3d, plot_three_matrix_lists_with_pca_3d)
# from visual import *

# Function to create SU(2) matrix given theta, phi, psi
def su2_matrix(theta, phi, psi):
    return np.array([
        [np.cos(theta) * np.exp(1j * phi), np.sin(theta) * np.exp(1j * psi)],
        [-np.sin(theta) * np.exp(-1j * psi), np.cos(theta) * np.exp(-1j * phi)]
    ])

# Function to assign parameters based on Strategy 1
def assign_parameters(G):
    n = G.number_of_nodes()
    max_degree = max(dict(G.degree()).values()) if G.number_of_nodes() > 0 else 1
    
    # Initialize parameters
    theta = {}
    phi = {}
    psi = {}
    
    # Compute sum of neighbor degrees for psi
    neighbor_degree_sums = {}
    for node in G.nodes():
        neighbor_degree_sums[node] = sum(G.degree(neighbor) for neighbor in G.neighbors(node))
    max_neighbor_degree_sum = max(neighbor_degree_sums.values()) if neighbor_degree_sums else 1
    
    # Assign parameters
    for i, node in enumerate(G.nodes(), 1):
        degree = G.degree(node)
        theta[node] = np.pi * degree / max_degree if max_degree > 0 else np.pi / 2
        phi[node] = 2 * np.pi * (i - 1) / n
        psi[node] = 2 * np.pi * neighbor_degree_sums[node] / max_neighbor_degree_sum if max_neighbor_degree_sum > 0 else 0
    
    return theta, phi, psi

def extend_matrices_random(matrices_random, num_new_matrices):
    """
    Extends the matrices_random dictionary by generating new matrices through multiplication.

    Parameters:
        matrices_random (dict): Existing SU(2) matrices.
        num_new_matrices (int): Number of new matrices to generate.

    Returns:
        dict: Extended matrices_random dictionary with new matrices added.
    """
    # Get the list of existing matrices
    existing_matrices = list(matrices_random.values())
    num_existing = len(existing_matrices)
    
    # Generate new matrices
    for i in range(num_new_matrices):
        # Randomly select two matrices from the existing set
        matrix_a = existing_matrices[np.random.randint(0, num_existing)]
        matrix_b = existing_matrices[np.random.randint(0, num_existing)]
        
        # Multiply the matrices to generate a new matrix
        new_matrix = np.dot(matrix_a, matrix_b)
        
        # Normalize the new matrix to ensure it remains in SU(2)
        norm = np.linalg.norm(new_matrix)
        new_matrix /= norm if norm != 0 else 1
        
        # Add the new matrix to matrices_random with a new key
        matrices_random[f'new_{i}'] = new_matrix
    
    return matrices_random

def generate_matrix_powers(matrices_random, N):
    """
    Generates a list of matrices {U, U^2, U^3, ..., U^N} using a randomly selected matrix U from matrices_random.

    Parameters:
        matrices_random (dict): Dictionary of SU(2) matrices.
        N (int): The maximum power to compute.

    Returns:
        list: A list of 2x2 matrices [U, U^2, U^3, ..., U^N].
    """
    # Randomly select a matrix U from matrices_random
    U = random.choice(matrices_random)
    
    # Normalize the matrix to ensure it remains in SU(2)
    norm = np.linalg.norm(U)
    U = U / norm if norm != 0 else U
    
    # Generate the powers of U
    matrix_powers = [np.linalg.matrix_power(U, i) for i in range(1, N + 1)]
    
    return matrix_powers

def generate_subgroup_from_generators(matrices_random, max_steps=1000, tol=1e-8):
    """
    Generate as many unique elements as possible in the subgroup generated by matrices_random.

    Parameters:
        matrices_random (dict): Dictionary of SU(2) matrices (complex 2x2).
        max_steps (int): Maximum number of attempts to generate new elements.
        tol (float): Tolerance for considering two matrices as equal.

    Returns:
        list: List of unique subgroup elements (2x2 complex matrices).
    """
    # Start with the generators
    subgroup = [mat for mat in matrices_random.values()]
    # Store flattened matrices for fast comparison
    flat_subgroup = [mat.flatten() for mat in subgroup]

    for _ in range(max_steps):
        # Randomly pick two elements from the current subgroup
        a = subgroup[np.random.randint(len(subgroup))]
        b = subgroup[np.random.randint(len(subgroup))]
        # Multiply to get a new candidate
        candidate = np.dot(a, b)
        # Normalize
        norm = np.linalg.norm(candidate)
        candidate = candidate / norm if norm != 0 else candidate
        # Check if candidate is already in the subgroup (up to tolerance)
        is_new = True
        flat_candidate = candidate.flatten()
        for flat_existing in flat_subgroup:
            if np.allclose(flat_candidate, flat_existing, atol=tol):
                is_new = False
                break
        if is_new:
            subgroup.append(candidate)
            flat_subgroup.append(flat_candidate)
    return subgroup

def multiply_all_matrices(matrices_random):
    """
    Multiplies all matrices in matrices_random in order and returns the resulting matrix.

    Parameters:
        matrices_random (dict): Dictionary of SU(2) matrices (complex 2x2).

    Returns:
        np.ndarray: The product of all matrices (2x2 complex matrix).
    """
    matrices = list(matrices_random.values())
    if not matrices:
        raise ValueError("matrices_random is empty.")
    result = matrices[0]
    for mat in matrices[1:]:
        result = np.dot(result, mat)
    return result

# Example 1: Cycle Graph (10 nodes)
G_cycle = nx.cycle_graph(10)
theta_cycle, phi_cycle, psi_cycle = assign_parameters(G_cycle)
G_star = nx.star_graph(9)  # Central node 0, peripheral nodes 1 to 9
theta_star, phi_star, psi_star = assign_parameters(G_star)
G_random = nx.erdos_renyi_graph(10, 0.3, seed=42)  # 10 nodes, edge prob 0.3
theta_random, phi_random, psi_random = assign_parameters(G_random)

# Compute matrices for cycle graph
matrices_cycle = {node: su2_matrix(theta_cycle[node], phi_cycle[node], psi_cycle[node]) 
                 for node in G_cycle.nodes()}

matrices_star = {node: su2_matrix(theta_star[node], phi_star[node], psi_star[node]) 
                 for node in G_star.nodes()}

matrices_random = {node: su2_matrix(theta_random[node], phi_random[node], psi_random[node]) 
                   for node in G_random.nodes()}

############################################################
############################################################
##################### Visualize graphs #####################
############################################################
############################################################
# visualize_graph(G_star, theta_star, phi_star, psi_star, "Star Graph (10 Nodes)", layout='spring')
# visualize_graph(G_random, theta_random, phi_random, psi_random, "Random Graph (10 Nodes)", layout='spring')
# visualize_graph(G_cycle, theta_cycle, phi_cycle, psi_cycle, "Cycle Graph (10 Nodes)", layout='circular')

# visualize_bloch_vectors(matrices_cycle, matrices_star, matrices_random)
# visualize_parameters(theta_cycle, phi_cycle, psi_cycle, 
#                      theta_star, phi_star, psi_star, 
#                      theta_random, phi_random, psi_random)

# Call the function to plot all matrices

N = 100

subgroup = generate_subgroup_from_generators(matrices_random, max_steps=2000)
gen_random = multiply_all_matrices(matrices_random)
gen_random /= np.linalg.norm(gen_random) if np.linalg.norm(gen_random) != 0 else 1

gen_star = multiply_all_matrices(matrices_star)
gen_star /= np.linalg.norm(gen_star) if np.linalg.norm(gen_star) != 0 else 1

gen_cycle = multiply_all_matrices(matrices_cycle)
gen_cycle /= np.linalg.norm(gen_cycle) if np.linalg.norm(gen_cycle) != 0 else 1

print("Random Matrix:")
print(gen_random)
print("Star Matrix:")
print(gen_star)      
print("Cycle Matrix:")
print(gen_cycle)   
# plot_star_and_random_with_pca(matrices_star, matrices_random)
# plot_all_matrices_with_pca(matrices_cycle, matrices_star, matrices_random)

# Example usage
# N = 100  # Number of powers to generate
# matrix_powers = []
# for i in range(10):
#     matrix_powers.extend(generate_matrix_powers([matrices_random[i]], N))

k = 100
cyc_powers = []
star_powers = []
ran_powers = []
print("Generating matrix powers...")

cyc_powers.extend(generate_matrix_powers([gen_cycle], k))
star_powers.extend(generate_matrix_powers([gen_star], k))
ran_powers.extend(generate_matrix_powers([gen_random], k))

plot_three_matrix_lists_with_pca_3d(cyc_powers, star_powers, ran_powers,  labels=('cycle graph', 'star graph', 'random graph'))
# print(len(matrix_powers))


# Example usage:
# subgroup_elements = generate_subgroup_from_generators(matrices_random, max_steps=2000)
# print(f"Generated {len(subgroup_elements)} unique subgroup elements.")
